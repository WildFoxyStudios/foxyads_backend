
const mongoose = require('mongoose');
const { createClient } = require('@supabase/supabase-js');
const path = require('path');
const dotenv = require('dotenv');

// Load environment variables
dotenv.config({ path: path.join(__dirname, '../.env') });

// Helper to decrypt passwords if needed
// const Cryptr = require('cryptr');
// const cryptr = new Cryptr("myTotallySecretKey"); 

const mongoUrl = process.env.MongoDb_Connection_String;
const supabaseUrl = process.env.SUPABASE_URL;
const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;

if (!mongoUrl) {
    console.error("‚ùå Missing MongoDb_Connection_String in .env");
    process.exit(1);
}

if (!supabaseUrl || !supabaseServiceKey) {
    console.error("‚ùå Missing Supabase credentials in .env");
    process.exit(1);
}

const supabase = createClient(supabaseUrl, supabaseServiceKey);

// --- Define Minimal Mongo Models for reading ---
const userSchema = new mongoose.Schema({}, { strict: false });
const User = mongoose.model('User', userSchema);

const categorySchema = new mongoose.Schema({}, { strict: false });
const Category = mongoose.model('Category', categorySchema);

const adSchema = new mongoose.Schema({}, { strict: false });
const AdListing = mongoose.model('AdListing', adSchema);

const chatTopicSchema = new mongoose.Schema({}, { strict: false });
const ChatTopic = mongoose.model('ChatTopic', chatTopicSchema);

const chatSchema = new mongoose.Schema({}, { strict: false });
const Chat = mongoose.model('Chat', chatSchema);
// -----------------------------------------------

async function migrate() {
    try {
        console.log("üîÑ Connecting to MongoDB...");
        await mongoose.connect(mongoUrl);
        console.log("‚úÖ Connected to MongoDB");

        // 1. Migrate Users
        console.log("üîÑ Migrating Users...");
        const users = await User.find({}).lean();
        for (const user of users) {
            // Create user in Supabase Auth if needed, or just insert into profiles
            // Since we want to preserve passwords and they are reversible, we can create Auth users!

            let authUid = user.firebaseUid; // Is this reliable? Or should we generate new?

            // If we want to move away from Firebase, we should create new Supabase Auth users.
            // But we need the decrypted password.
            // let decryptedPassword = null;
            // if (user.password) {
            //   try {
            //      // decryptedPassword = cryptr.decrypt(user.password);
            //   } catch(e) { console.log('Failed to decrypt password for', user.email); }
            // }

            // Insert into public.profiles
            // Use upsert to avoid duplicates
            const { error: profileError } = await supabase.from('profiles').upsert({
                profile_id: user.profileId,
                name: user.name,
                email: user.email,
                phone_number: user.phoneNumber,
                address: user.address,
                login_type: user.loginType,
                auth_identity: user.authIdentity,
                fcm_token: user.fcmToken,
                firebase_uid: user.firebaseUid,
                auth_provider: user.authProvider,
                is_blocked: user.isBlocked,
                created_at: user.createdAt,
                updated_at: user.updatedAt
                // ... map other fields
            }, { onConflict: 'profile_id' });

            if (profileError) console.error(`Error migrating profile ${user.email}:`, profileError.message);
        }
        console.log(`‚úÖ Migrated ${users.length} users.`);


        // 2. Migrate Categories
        console.log("üîÑ Migrating Categories...");
        const categories = await Category.find({}).lean();
        for (const cat of categories) {
            // We need to map ObjectId to BigInt id or wait?
            // Supabase `categories.id` is BigInt GENERATED BY DEFAULT.
            // We can force insert IDs if we change the schema to UUID or if we map ObjectId -> Int.
            // FOR NOW: Let Postgres generate IDs and we lose the old ID specific mapping unless we store `mongo_id` in Supabase.
            // OR: We added `slug` which might be unique enough.

            const { data: newCat, error: catError } = await supabase.from('categories').insert({
                name: cat.name,
                slug: cat.slug,
                image: cat.image,
                is_active: cat.isActive,
                // parent_id: ... needs mapping from mongo ID to new value
            }).select();

            if (catError) console.error(`Error migrating category ${cat.name}:`, catError.message);
        }

        // ... Add listings, chats etc.

        console.log("‚úÖ Migration Complete.");
        process.exit(0);

    } catch (error) {
        console.error("‚ùå Migration Failed:", error);
        process.exit(1);
    }
}

migrate();
